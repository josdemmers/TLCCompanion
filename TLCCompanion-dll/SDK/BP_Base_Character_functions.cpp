#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Base_Character

#include "Basic.hpp"

#include "BP_Base_Character_classes.hpp"
#include "BP_Base_Character_parameters.hpp"


namespace SDK
{

// Function BP_Base_Character.BP_Base_Character_C.ApplyCrushDamage
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Base_Character_C::ApplyCrushDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ApplyCrushDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.Audio_Death_Filter__FinishedFunc
// (BlueprintEvent)

void ABP_Base_Character_C::Audio_Death_Filter__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "Audio_Death_Filter__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.Audio_Death_Filter__UpdateFunc
// (BlueprintEvent)

void ABP_Base_Character_C::Audio_Death_Filter__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "Audio_Death_Filter__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.BindSkillUnlockQuest
// (BlueprintCallable, BlueprintEvent)

void ABP_Base_Character_C::BindSkillUnlockQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "BindSkillUnlockQuest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.BndEvt__BP_Base_Character_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Base_Character_C::BndEvt__BP_Base_Character_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "BndEvt__BP_Base_Character_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature");

	Params::BP_Base_Character_C_BndEvt__BP_Base_Character_CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_2_OnPontoonEnteredWater__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// const struct FSphericalPontoon&         Pontoon                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void ABP_Base_Character_C::BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_2_OnPontoonEnteredWater__DelegateSignature(const struct FSphericalPontoon& Pontoon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_2_OnPontoonEnteredWater__DelegateSignature");

	Params::BP_Base_Character_C_BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_2_OnPontoonEnteredWater__DelegateSignature Parms{};

	Parms.Pontoon = std::move(Pontoon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_3_OnPontoonExitedWater__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// const struct FSphericalPontoon&         Pontoon                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void ABP_Base_Character_C::BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_3_OnPontoonExitedWater__DelegateSignature(const struct FSphericalPontoon& Pontoon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_3_OnPontoonExitedWater__DelegateSignature");

	Params::BP_Base_Character_C_BndEvt__BP_FirstPersonCharacter_SwimmingBuoyancyComponent_K2Node_ComponentBoundEvent_3_OnPontoonExitedWater__DelegateSignature Parms{};

	Parms.Pontoon = std::move(Pontoon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.CalculateFallDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Damage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::CalculateFallDamage(double Velocity, double* Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "CalculateFallDamage");

	Params::BP_Base_Character_C_CalculateFallDamage Parms{};

	Parms.Velocity = Velocity;

	UObject::ProcessEvent(Func, &Parms);

	if (Damage != nullptr)
		*Damage = Parms.Damage;
}


// Function BP_Base_Character.BP_Base_Character_C.ExecuteUbergraph_BP_Base_Character
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::ExecuteUbergraph_BP_Base_Character(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ExecuteUbergraph_BP_Base_Character");

	Params::BP_Base_Character_C_ExecuteUbergraph_BP_Base_Character Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.FilterDismantleOutput
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const TMap<class UVoyageItem*, int32>&  TargetMap                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    HasPattern                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class UVoyageItem*, int32>*        Output                                                 (Parm, OutParm)

void ABP_Base_Character_C::FilterDismantleOutput(class AActor* TargetActor, const TMap<class UVoyageItem*, int32>& TargetMap, bool HasPattern, TMap<class UVoyageItem*, int32>* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "FilterDismantleOutput");

	Params::BP_Base_Character_C_FilterDismantleOutput Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetMap = std::move(TargetMap);
	Parms.HasPattern = HasPattern;

	UObject::ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = std::move(Parms.Output);
}


// Function BP_Base_Character.BP_Base_Character_C.GetActiveHolsterActorADSOffset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector*                         Offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::GetActiveHolsterActorADSOffset(struct FVector* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "GetActiveHolsterActorADSOffset");

	Params::BP_Base_Character_C_GetActiveHolsterActorADSOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function BP_Base_Character.BP_Base_Character_C.GetControllerTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FTransform*                      Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::GetControllerTransform(struct FTransform* Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "GetControllerTransform");

	Params::BP_Base_Character_C_GetControllerTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);
}


// Function BP_Base_Character.BP_Base_Character_C.GetPersistentActorComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UVoyagePersistentActorComponent*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class UVoyagePersistentActorComponent* ABP_Base_Character_C::GetPersistentActorComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "GetPersistentActorComponent");

	Params::BP_Base_Character_C_GetPersistentActorComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Base_Character.BP_Base_Character_C.OnActiveHolsterStateChanged_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EVoyageEquipmentInterpStateType         InType                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EVoyageEquipmentInterpState             PrevState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EVoyageEquipmentInterpState             NewState                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnActiveHolsterStateChanged_Event(EVoyageEquipmentInterpStateType InType, EVoyageEquipmentInterpState PrevState, EVoyageEquipmentInterpState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnActiveHolsterStateChanged_Event");

	Params::BP_Base_Character_C_OnActiveHolsterStateChanged_Event Parms{};

	Parms.InType = InType;
	Parms.PrevState = PrevState;
	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnActiveHolsterStateValueChanged_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EVoyageEquipmentInterpStateType         InType                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnActiveHolsterStateValueChanged_Event(EVoyageEquipmentInterpStateType InType, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnActiveHolsterStateValueChanged_Event");

	Params::BP_Base_Character_C_OnActiveHolsterStateValueChanged_Event Parms{};

	Parms.InType = InType;
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnAliveChangedDelegate_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AVoyageBaseCharacter*             Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Alive                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnAliveChangedDelegate_Event(class AVoyageBaseCharacter* Character, bool Alive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnAliveChangedDelegate_Event");

	Params::BP_Base_Character_C_OnAliveChangedDelegate_Event Parms{};

	Parms.Character = Character;
	Parms.Alive = Alive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnCharacterLogFragmentUnlocked_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AVoyagePlayerController*          InPlayerController                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UVoyageLogFragmentUnlockSource*   Source                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UVoyageLogData*                   log                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   FragmentIndex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Fragments                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnCharacterLogFragmentUnlocked_Event(class AVoyagePlayerController* InPlayerController, class UVoyageLogFragmentUnlockSource* Source, class UVoyageLogData* log, int32 FragmentIndex, int32 Fragments)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnCharacterLogFragmentUnlocked_Event");

	Params::BP_Base_Character_C_OnCharacterLogFragmentUnlocked_Event Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.Source = Source;
	Parms.log = log;
	Parms.FragmentIndex = FragmentIndex;
	Parms.Fragments = Fragments;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnCustomDataSave
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<uint8>*                          OutData                                                (Parm, OutParm)

void ABP_Base_Character_C::OnCustomDataSave(TArray<uint8>* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnCustomDataSave");

	Params::BP_Base_Character_C_OnCustomDataSave Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function BP_Base_Character.BP_Base_Character_C.OnJumped
// (Event, Public, BlueprintEvent)

void ABP_Base_Character_C::OnJumped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnJumped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.OnLanded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Base_Character_C::OnLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnLanded");

	Params::BP_Base_Character_C_OnLanded Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnMontageEnded_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bInterrupted                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnMontageEnded_Event(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnMontageEnded_Event");

	Params::BP_Base_Character_C_OnMontageEnded_Event Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnMontageStarted_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnMontageStarted_Event(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnMontageStarted_Event");

	Params::BP_Base_Character_C_OnMontageStarted_Event Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnPersistentActorPostLoad
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Version                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnPersistentActorPostLoad(int32 Version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnPersistentActorPostLoad");

	Params::BP_Base_Character_C_OnPersistentActorPostLoad Parms{};

	Parms.Version = Version;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnPlayerSkillUnlocked
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AVoyagePlayerState*               InPlayerState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UVoyageSkill*                     InSkill                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnPlayerSkillUnlocked(class AVoyagePlayerState* InPlayerState, class UVoyageSkill* InSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnPlayerSkillUnlocked");

	Params::BP_Base_Character_C_OnPlayerSkillUnlocked Parms{};

	Parms.InPlayerState = InPlayerState;
	Parms.InSkill = InSkill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnUnitStateCompExpired
// (BlueprintCallable, BlueprintEvent)

void ABP_Base_Character_C::OnUnitStateCompExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnUnitStateCompExpired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.OnVisualizeDamage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class UDamageType*                InDamageType                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::OnVisualizeDamage(const struct FVector& Location, float Amount, const class UDamageType* InDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnVisualizeDamage");

	Params::BP_Base_Character_C_OnVisualizeDamage Parms{};

	Parms.Location = std::move(Location);
	Parms.Amount = Amount;
	Parms.InDamageType = InDamageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.OnVisualizeDeath
// (Event, Public, BlueprintEvent)

void ABP_Base_Character_C::OnVisualizeDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "OnVisualizeDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.ReceiveAnyDamage
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class UDamageType*                DamageType                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AController*                      InstigatedBy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::ReceiveAnyDamage(float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ReceiveAnyDamage");

	Params::BP_Base_Character_C_ReceiveAnyDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Base_Character_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ReceiveTick");

	Params::BP_Base_Character_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.RecycleItem
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UVoyageItem*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class UVoyageItem*, int32>*        ItemsOut                                               (Parm, OutParm)
// float                                   Multiplier                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    EmptyMap                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxLevel                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ForceChance                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          SeedObject                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Instigator_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Base_Character_C::RecycleItem(class UVoyageItem* Item, float Count, TMap<class UVoyageItem*, int32>* ItemsOut, float Multiplier, bool EmptyMap, int32 Level, int32 MaxLevel, float ForceChance, class UObject* SeedObject, class AActor* Instigator_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "RecycleItem");

	Params::BP_Base_Character_C_RecycleItem Parms{};

	Parms.Item = Item;
	Parms.Count = Count;
	Parms.Multiplier = Multiplier;
	Parms.EmptyMap = EmptyMap;
	Parms.Level = Level;
	Parms.MaxLevel = MaxLevel;
	Parms.ForceChance = ForceChance;
	Parms.SeedObject = SeedObject;
	Parms.Instigator_0 = Instigator_0;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemsOut != nullptr)
		*ItemsOut = std::move(Parms.ItemsOut);

	return Parms.ReturnValue;
}


// Function BP_Base_Character.BP_Base_Character_C.SetRagdoll
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSimulate                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::SetRagdoll(bool bSimulate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "SetRagdoll");

	Params::BP_Base_Character_C_SetRagdoll Parms{};

	Parms.bSimulate = bSimulate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.SetupMeleeMontage
// (BlueprintCallable, BlueprintEvent)

void ABP_Base_Character_C::SetupMeleeMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "SetupMeleeMontage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.ShouldShowGlitchPostProcess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::ShouldShowGlitchPostProcess(bool* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ShouldShowGlitchPostProcess");

	Params::BP_Base_Character_C_ShouldShowGlitchPostProcess Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Base_Character.BP_Base_Character_C.ShowCrowbar
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Montage                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bNewVisibility                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::ShowCrowbar(class UObject* Montage, bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "ShowCrowbar");

	Params::BP_Base_Character_C_ShowCrowbar Parms{};

	Parms.Montage = Montage;
	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.SpawnFabricatorInventoryItems
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Base_Character_C::SpawnFabricatorInventoryItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "SpawnFabricatorInventoryItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Base_Character.BP_Base_Character_C.StartTutorialQuest
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UVoyageQuest*                     Quest                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::StartTutorialQuest(class UVoyageQuest* Quest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "StartTutorialQuest");

	Params::BP_Base_Character_C_StartTutorialQuest Parms{};

	Parms.Quest = Quest;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.TickSwarmAttractor
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UVoyageSwarmAttractorComponent*   Attractor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AVoyageSwarmHandler*              SwarmHandler                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const TArray<int32>&                    Particles                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void ABP_Base_Character_C::TickSwarmAttractor(float DeltaTime, class UVoyageSwarmAttractorComponent* Attractor, class AVoyageSwarmHandler* SwarmHandler, const TArray<int32>& Particles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "TickSwarmAttractor");

	Params::BP_Base_Character_C_TickSwarmAttractor Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Attractor = Attractor;
	Parms.SwarmHandler = SwarmHandler;
	Parms.Particles = std::move(Particles);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.UpdateADSCamera
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Base_Character_C::UpdateADSCamera(double Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "UpdateADSCamera");

	Params::BP_Base_Character_C_UpdateADSCamera Parms{};

	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Base_Character.BP_Base_Character_C.HasCustomData
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Base_Character_C::HasCustomData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "HasCustomData");

	Params::BP_Base_Character_C_HasCustomData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Base_Character.BP_Base_Character_C.PersistTranform
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Base_Character_C::PersistTranform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Base_Character_C", "PersistTranform");

	Params::BP_Base_Character_C_PersistTranform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

